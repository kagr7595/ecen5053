#The MQTT Over Websockets was almost completely generated by following the Readme for https://github.com/aws/aws-iot-device-sdk-python
#I did need to update the version installed by pip to v1.4.2 due to an update from AWS with ats in the endpoint
#I used this command: sudo pip3 install -e git://github.com/aws/aws-iot-device-sdk-python.git@v1.4.2#egg=AWS_python_ver_ats_tag_fix

# Import SDK packages
from AWSIoTPythonSDK.MQTTLib import AWSIoTMQTTClient


# Used https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/robot/buttons_and_switches
#imports Raspberry Pi GPIO library
import RPi.GPIO as GPIO

#use time library to delay led light switch handle debouncing the switch
import time

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QSizePolicy, QTableWidget,QTabWidget, QTextEdit, QHBoxLayout, QGridLayout, QDialog, QLabel,QComboBox, QStyleFactory, QRadioButton, QVBoxLayout
from PyQt5.QtCore import QDate, QTime, Qt, QDateTime, QTimer

#needed for the database[9]
import redis
import json

#What board layout am I using
GPIO.setmode(GPIO.BCM)

#Using GPIO 19 as an INPUT
GPIO.setup(19,GPIO.IN)

input = GPIO.input(19)
prev_input = ~input


# Custom MQTT message callback
def customCallback(client, userdata, message):
    print("Received a new message: ")
    print(message.payload)
    print("from topic: ")
    print(message.topic)
    print("--------------\n\n")

#Server Topic
server_topic = "RPiServer1"

#Client Topic (requests to Server?)
client_topic = "RPiClient1"

#Drop oldest messages if over queue request offline limit
AWSIoTMQTTClient.DROP_OLDEST = 1
AWSIoTMQTTClient.DROP_NEWEST = 0

# For Websocket connection
myMQTTClient = AWSIoTMQTTClient("myClientID", useWebsocket=True)

# Configurations
# For Websocket
myMQTTClient.configureEndpoint("afmi9oh8t5vtj-ats.iot.us-east-1.amazonaws.com", 443)

# For Websocket, we only need to configure the root CA
myMQTTClient.configureCredentials("/home/pi/class/Server1/AmazonRootCA1_Server1.pem")

myMQTTClient.configureOfflinePublishQueueing(-1)  # Infinite offline Publish queueing
myMQTTClient.configureDrainingFrequency(2)  # Draining: 2 Hz
myMQTTClient.configureConnectDisconnectTimeout(10)  # 10 sec
myMQTTClient.configureMQTTOperationTimeout(5)  # 5 sec


#myMQTTClient.connect()
#myMQTTClient.subscribe(server_topic, 1, customCallback)
#myMQTTClient.subscribe(client_topic, 1, customCallback)
#myMQTTClient.unsubscribe(server_topic)
#myMQTTClient.disconnect()
last_connected_datetime = QDateTime.currentDateTime()
time_between_messages_sec = 0

# Loop forever
# Check for change in reedswitch, if change then publish a message with the updated redis information
loopCount = 0
reset = 1
while True:
    #take a reading from RPi
    input = GPIO.input(19)

    #if last reading was low and this one high, print and send message
    if(input != prev_input):        
        #get current datetime / Used [6] for reference
        current_datetime = QDateTime.currentDateTime()
        current_datetime_str = current_datetime.toString(Qt.DefaultLocaleLongDate)
        if(reset == 0):
            time_between_messages_sec = last_connected_datetime.secsTo(current_datetime)
            print('Seconds between messages: %d\n' % (time_between_messages_sec))
            
        
        if((time_between_messages_sec > 240) | reset):
            #try reconnecting as you may have been disconnected
            #connect and subscribe
            myMQTTClient.connect()
            myMQTTClient.subscribe(server_topic, 1, customCallback)
            myMQTTClient.subscribe(client_topic, 1, customCallback)
            
        message = {}
        if(input == 1):
            print("Reed Switch closed")
            message['message'] = "Reed Switch Closed -- Gate Closed!"
            message['status'] = 0
        else:
            print("Reed Switch open")
            message['message'] = "Reed Switch Open -- Gate Open!"
            message['status'] = 1
        prev_input = input
        
        message['sequence'] = loopCount
        message['program_reset'] = reset
        messageJson = json.dumps(message)
        myMQTTClient.publish(server_topic, messageJson, 1)
        print('Published topic %s: %s\n' % (server_topic, messageJson))
        loopCount += 1

        last_connected_datetime = current_datetime
        reset = 0
    
    
    time.sleep(1)



#don't need to disconnect as it is likely it will disconnect with the long waits in any case
#myMQTTClient.disconnect()
